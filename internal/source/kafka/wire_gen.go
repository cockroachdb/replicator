// Code generated by Wire. DO NOT EDIT.

//go:generate go run -mod=mod github.com/google/wire/cmd/wire
//go:build !wireinject
// +build !wireinject

package kafka

import (
	"github.com/cockroachdb/field-eng-powertools/stopper"
	"github.com/cockroachdb/replicator/internal/conveyor"
	"github.com/cockroachdb/replicator/internal/script"
	"github.com/cockroachdb/replicator/internal/sequencer/besteffort"
	"github.com/cockroachdb/replicator/internal/sequencer/core"
	"github.com/cockroachdb/replicator/internal/sequencer/decorators"
	"github.com/cockroachdb/replicator/internal/sequencer/immediate"
	"github.com/cockroachdb/replicator/internal/sequencer/retire"
	"github.com/cockroachdb/replicator/internal/sequencer/scheduler"
	script2 "github.com/cockroachdb/replicator/internal/sequencer/script"
	"github.com/cockroachdb/replicator/internal/sequencer/staging"
	"github.com/cockroachdb/replicator/internal/sequencer/switcher"
	"github.com/cockroachdb/replicator/internal/sinkprod"
	"github.com/cockroachdb/replicator/internal/staging/checkpoint"
	"github.com/cockroachdb/replicator/internal/staging/leases"
	"github.com/cockroachdb/replicator/internal/staging/memo"
	"github.com/cockroachdb/replicator/internal/staging/stage"
	"github.com/cockroachdb/replicator/internal/staging/version"
	"github.com/cockroachdb/replicator/internal/target/apply"
	"github.com/cockroachdb/replicator/internal/target/dlq"
	"github.com/cockroachdb/replicator/internal/target/load"
	"github.com/cockroachdb/replicator/internal/target/schemawatch"
	"github.com/cockroachdb/replicator/internal/util/applycfg"
	"github.com/cockroachdb/replicator/internal/util/diag"
)

// Injectors from injector.go:

// Start creates a Kafka logical replication loop using the
// provided configuration.
func Start(ctx *stopper.Context, config *Config) (*Kafka, error) {
	diagnostics := diag.New(ctx)
	configs, err := applycfg.ProvideConfigs(diagnostics)
	if err != nil {
		return nil, err
	}
	scriptConfig := &config.Script
	loader, err := script.ProvideLoader(ctx, configs, scriptConfig, diagnostics)
	if err != nil {
		return nil, err
	}
	eagerConfig := ProvideEagerConfig(config, loader)
	targetConfig := &eagerConfig.Target
	stagingConfig := &eagerConfig.Staging
	stagingPool, err := sinkprod.ProvideStagingPool(ctx, stagingConfig, diagnostics, targetConfig)
	if err != nil {
		return nil, err
	}
	stagingSchema, err := sinkprod.ProvideStagingDB(ctx, stagingConfig, stagingPool)
	if err != nil {
		return nil, err
	}
	memoMemo, err := memo.ProvideMemo(ctx, stagingPool, stagingSchema)
	if err != nil {
		return nil, err
	}
	checker := version.ProvideChecker(stagingPool, memoMemo)
	targetPool, err := sinkprod.ProvideTargetPool(ctx, checker, targetConfig, diagnostics)
	if err != nil {
		return nil, err
	}
	targetStatements, err := sinkprod.ProvideStatementCache(ctx, targetConfig, targetPool, diagnostics)
	if err != nil {
		return nil, err
	}
	dlqConfig := &eagerConfig.DLQ
	backup := schemawatch.ProvideBackup(memoMemo, stagingPool)
	watchers, err := schemawatch.ProvideFactory(ctx, targetPool, diagnostics, backup)
	if err != nil {
		return nil, err
	}
	dlQs := dlq.ProvideDLQs(dlqConfig, targetPool, watchers)
	loadLoader, err := load.ProvideLoader(targetStatements, targetPool)
	if err != nil {
		return nil, err
	}
	acceptor, err := apply.ProvideAcceptor(ctx, targetStatements, configs, diagnostics, dlQs, loadLoader, targetPool, watchers)
	if err != nil {
		return nil, err
	}
	conveyorConfig := ProvideConveyorConfig(config)
	checkpoints, err := checkpoint.ProvideCheckpoints(ctx, stagingPool, stagingSchema)
	if err != nil {
		return nil, err
	}
	sequencer := script2.ProvideSequencer(loader, targetPool, watchers)
	sequencerConfig := &eagerConfig.Sequencer
	stageConfig := &eagerConfig.Stage
	stagers := stage.ProvideFactory(stageConfig, stagingPool, stagingSchema, ctx)
	retireRetire := retire.ProvideRetire(sequencerConfig, stagingPool, stagers)
	schedulerScheduler, err := scheduler.ProvideScheduler(ctx, sequencerConfig)
	if err != nil {
		return nil, err
	}
	bestEffort := besteffort.ProvideBestEffort(sequencerConfig, schedulerScheduler, stagers, stagingPool, watchers)
	typesLeases, err := leases.ProvideLeases(ctx, stagingPool, stagingSchema)
	if err != nil {
		return nil, err
	}
	coreCore := core.ProvideCore(sequencerConfig, typesLeases, schedulerScheduler, targetPool)
	marker := decorators.ProvideMarker(stagingPool, stagers)
	once := decorators.ProvideOnce(stagingPool, stagers)
	retryTarget := decorators.ProvideRetryTarget(targetPool)
	immediateImmediate := immediate.ProvideImmediate(sequencerConfig, targetPool, marker, once, retryTarget, stagers)
	stagingStaging := staging.ProvideStaging(sequencerConfig, marker, stagers, stagingPool)
	switcherSwitcher := switcher.ProvideSequencer(bestEffort, coreCore, diagnostics, immediateImmediate, stagingStaging, stagingPool, targetPool)
	conveyors, err := conveyor.ProvideConveyors(ctx, acceptor, conveyorConfig, checkpoints, sequencer, retireRetire, switcherSwitcher, watchers)
	if err != nil {
		return nil, err
	}
	conn, err := ProvideConn(ctx, config, conveyors)
	if err != nil {
		return nil, err
	}
	kafka := &Kafka{
		Conn:        conn,
		Diagnostics: diagnostics,
	}
	return kafka, nil
}

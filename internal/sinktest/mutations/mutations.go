// Copyright 2023 The Cockroach Authors
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// SPDX-License-Identifier: Apache-2.0

// Package mutations contains a helper to generate mutations.
package mutations

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"math/rand"
	"reflect"
	"time"

	"github.com/cockroachdb/cdc-sink/internal/types"
	"github.com/cockroachdb/cdc-sink/internal/util/hlc"
	"github.com/gofrs/uuid"
)

// Payload instances are generated by a Generator.
type Payload struct {
	PK  uuid.UUID `json:"pk"`
	Ver int       `json:"ver"`
	TS  time.Time `json:"ts"`
}

// Equal compares mutations, but treats a nil slice and a slice
// containing "null" as equivalent.
func Equal(a types.Mutation, b types.Mutation) bool {
	return equalish(a.Before, b.Before) &&
		equalish(a.Data, b.Data) &&
		equalish(a.Key, b.Key) &&
		reflect.DeepEqual(a.Meta, b.Meta) &&
		hlc.Compare(a.Time, b.Time) == 0
}

// equalish returns true if the messages are both nullish or both
// contain the same data.
func equalish(a, b json.RawMessage) bool {
	if IsNullish(a) {
		return IsNullish(b)
	}
	return bytes.Equal(a, b)
}

// IsNullish returns true if the message is empty or contains the JSON
// null token.
func IsNullish(raw json.RawMessage) bool {
	return len(raw) == 0 || bytes.Equal(raw, []byte("null"))
}

// Generator returns a channel from which an infinite number of
// mutations can be read. The total number of distinct payload PK value
// is controlled with the idCount argument. The mutations will have
// Payload instances encoded into their Data or Key fields, based on the
// deleteFraction value.
func Generator(ctx context.Context, idCount int, deleteFraction float32) <-chan types.Mutation {
	now := time.Now().UTC().Round(time.Second)
	allPayloads := make([]Payload, idCount)
	for i := range allPayloads {
		allPayloads[i].PK, _ = uuid.NewV4()
		allPayloads[i].TS = now
	}

	muts := make(chan types.Mutation, idCount)
	go func() {
		defer close(muts)

		idx := 0
		for {
			now := time.Now().UTC()
			mut := types.Mutation{Time: hlc.From(now)}
			mut.Key = json.RawMessage(fmt.Sprintf(`["%s"]`, allPayloads[idx].PK))

			if rand.Float32() >= deleteFraction {
				allPayloads[idx].TS = now
				allPayloads[idx].Ver++

				var err error
				mut.Data, err = json.Marshal(allPayloads[idx])
				if err != nil {
					panic(err)
				}
				mut.Before = mut.Data
			}

			select {
			case <-ctx.Done():
				return
			case muts <- mut:
				if idx >= idCount-1 {
					idx = 0
				} else {
					idx++
				}
			}
		}
	}()

	return muts
}
